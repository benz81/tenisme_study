기본 kotlin 간단 요약





//// 코틀린의 특징 및 기본
 ☆ 아래에 이미 적혀있는 내용이어도 여기에 다시 적어도 됨.
└ 변수를 선언할 때 객체를 바로 할당하지 않는 경우에는 기본적으로 컴파일이 되지 않음.
└ "타입 추론"이 가능해 많은 경우 자료형 입력을 생략할 수 있음.
└ 상속 금지가 디폴트임.
└ 파일 내에 적힌 pakage 키워드를 기준으로 컴파일함.
	└ 폴더 구조와 패키지명을 일치시키지 않아도 됨.
	└ 클래스명과 파일명이 일치하지 않아도 됨.
└ 패키지를 명시하지 않으면 자동으로 default 패키지로 묶임.
└ 하나의 파일에 여러개의 클래스를 넣어도 알아서 컴파일이 가능함.
└ 객체지향 및 함수형 언어

// 오류 모음
└ ANR(Application Not Responding) : 응답없음 오류





//// 기본 변수 선언 및 자료형

var a: Int = 1
└ var <= 변수 선언
└ val <= 변수 선언
	└ 이후 "객체"를 다시 선언할 수 없음
	└ 객체 내부의 값은 변경이 가능.
	└ val은 선언과 동시에 값을 가져야만 함

var b: Int? = null
└ 자료형+? <= null이 가능한 자료형으로 선언

// 변수에 대해 주의해야 할 내용
var는 한 번 할당한 객체가 있더라도 다른 객체로 변경하여 할당할 수 있다.
ex) var a = 0
	 a = 1 이 가능

val은 객체를 한 번 할당하면 할당된 객체를 다시 변경할 수 없다.
ex) val a = 0
	 a = 1 이 불가능

val은 할당된 객체를 바꿀 수 없을 뿐이지 객체 내부의 속성을 변경할 수 없는 것은 아니다.





//// 자료형별 선언(및 리터럴) 방법

var intValue: Int = 1234
└ 32bits 10진수

var longValue: Long = 1234L
└ 64bits 10진수

var intValueByHex: Int = 0x1af
└ 16진수

var intValueByBin: Int = 0b10110110
└ 2진수

☆ Kotlin은 8진수 표기는 지원하지 않음.

var doubleValue: Double = 123.5
var doubleValueWithExp: Double = 123.5e10

var floatValue: Float = 123.5F
└ 16bits의 Float형으로 취급

var charValue: Char = 'a'
var koreanCharValue: Char = '가'

var booleanValue: Boolean = true

var stringValue: String = "one line string test"
var multilineStringValue : String = """multiline
string
value"""
└ 줄바꿈과 특수문자까지 그대로 사용할 수 있음

// Any
└ 어떤 자료형이든 상관없이 호환되는 코틀린 최상위 자료형





//// 문자열 안에서 사용할 수 있는 기호들

\t : 탭 
\b : 백스페이스 
\r : 첫 열로 커서 옮김 
\n : 개행 
\' : 작은따옴표 
\" : 큰 따옴표 
\\ : 역슬래시 
\$ : $문자 
\uxxxx : 유니코드 문자





//// (명시적) 형변환

var d: Long = a.toLong()
.toByte()
.toShort()
.toInt()
.toLong()
.toFloat()
.toDouble()
.toFloat()
.toDouble()
.toChar()





//// 일반 배열

var intArr: Array<Int> = arrayOf(1, 2, 3, 4, 5)
└ 한 번 설정한 크기는 변경할 수 없음.

var nullArr: Array<Int?> = arrayOfNulls<Int>(5)
└ Null로 채워진 빈 공간 5개 생성





//// 함수

fun add(a: Int, b: Int, c: Int): Int {
	return a+b+c
}
└ Int값을 리턴하고(: Int) Int 자료형의 a, b, c 파라미터를 받음

// 단일 표현식 함수

fun add2(a: Int, b: Int, c: Int) = a+b+c
└ 리턴값의 자료형이 추론되므로 리턴 표시(: Int & return) 생략됨.
	└ "타입 추론"
└ 간단한 함수이므로 {} 생략되고 = 로 대체됨.

// 함수 사용

add(5, 6, 7)





//// 조건문 ( if )

if(e > 10) {
	println("a는 10보다 크다")
} else {
	println("a는 10보다 작다")
}





//// 비교 연산자

부등호 : <  <=  >  >=  ==  !=

is : 자료형이 맞는지 체크한다
└ ex) a is Int

!is : 자료형이 틀렸는지를 체크한다

* is는 instanceOf를 대신하기도 한다.



//// 조건문 ( when )

// 동작을 반환하는 when

fun doWhen(a: Any) {
	when(a) {
		1 -> println("정수 1")
		"DiMo" -> println("디모의 코틀린 강좌")
		is Long -> println("Long 타입")
		!is String -> println("String 타입이 아님")
		else -> println("어떤 조건도 만족하지 않음")
		in 2..10 -> println("2~10사이의 값")
	}
}

// 값을 반환하는 when

fun doWhen(a: Any) {
	var result = when(a) {
		1 -> "정수 1"
		"DiMo" -> "디모의 코틀린 강좌"
		is Long -> "Long 타입"
		!is String -> "String 타입이 아님"
		else -> "어떤 조건도 만족하지 않음"
	}
}





//// 반복문 ( while )

// 일반 while

var a = 0
while(a < 5) { 
	println(a++) 
}
└ true일 때까지 while에 따르는 구문을 수행
└ a++ : 후위 증가 연산자. 화면에 출력되고 나서 증가값이 반영됨
└ ++a : 전위 증가 연산자. 증가값이 먼저 반영되고 나서 화면에 출력됨

// do-while

var a = 0
do {
	println(a++)
} while (a < 5)
└ do를 조건없이 무조건 한 번 실행한 다음 while 조건에 따라 do 내부를 반복 실행함





//// 반복문 ( for )

// 기본 for

for(i in 0..10) {
	print(i)
}

// n단계씩 건너뛰는 for

for(i in 0..9 step 3) {
	print(i)
}
└ 0, 3, 6, 9를 반환

// 역순 for

for(i in 9 downTo 0) {
	print(i)
}
└ 여기에도 step n을 붙일 수 있음.

// 알파벳 for

for(i in 'a'..'e') {
	print(i)
}
└ Char 자료형 'a'~'z'를 숫자 대신 기입 가능

* !in은 for loop와 generic에는 쓰일 수 없다.



//// 코드 흐름 제어

// return
└ 별다른 것 없음.

// break

for(i in 1..10) {
	if(i == 3) break
	println(i)
}
└ 구문이 실행되는 중간에 즉시 반복문을 종료하고 다음 구문으로 넘어감

// continue

for(i in 1..10) {
	if(i == 3) continue
	println(i)
}
└ 자신이 포함된 구문의 다음 반복조건으로 즉시 넘어감.
└ continue가 수행 될 때 continue 아래에 있는 코드들은 수행하지 않음.

// label로 for 빠져나오기

loop@for(i in 1..10){
	for(j in 1..10){
		if(i == 1 && j == 2) break@loop
		println("i : $i, j : $j")
	}
}
└ 지정한 라벨을 기준으로 break하거나 continue함
└ $+변수이름 or $+{변수이름} : 문자열 안에서 사용함. 변수 이름에 해당하는 변수값으로 대체되어 출력됨





//// 논리형 연산자

&& : and
|| : or
! : not

// 예시

var h = 6
var i = 4
println(h>5 && i>5) <= false
println(h>5 || i>5) <= true





//// 클래스

// 자료(속성)만 저장하는 클래스

class Person(var name: String, val birthYear: Int)
└ 함수 없이 속성(멤버변수)만 있는 클래스는 위 입력만으로 구현이 완료됨

// 왠만한 것들은 있는 클래스

class Person(var name: String, val birthYear: Int) { 

	init { 
		println("${this.birthYear}년생 ${this.name}님이 생성되었습니다")
	}

	constructor(name: String) : this(name, 1997) { 
		println("보조생성자 사용됨")
	}

	fun introduce() {
		println("안녕하세요. ${this.birthYear}년생 ${this.name}입니다")
	}
}
└ 기본 생성자에서 받는 패러미터를 클래스 이름 옆에서 받는다. 
└ 패러미터에 기본값을 셋팅하려면 var a: Int 옆에 = 로 기본값을 추가해주면 됨.
└ init { }
	└ 파라미터 및 반환형이 없는 생성자. init은 인스턴스 생성 즉시 기본으로 수행됨
└ constructor(name: String) : this(name, 1997) { }
	└ 보조생성자의 예시. 보조생성자는 반드시 자기 자신의 기본 생성자를 통해 속성을 초기화해줘야 한다. ex) : this(name, 1997)

// 클래스 선언

var a = Person("김ㅁㅁ", 1990)
└ 기본생성자 사용해서 변수 a에 할당한 모습

Person("김ㅁㅁ")
└ 보조생성자 사용해서 선언한 모습

// 클래스 사용

a.name = "이ㄹㄹ"
└ 클래스 속성 변경

a.introduce()
└ 클래스의 기능(함수) 사용

Person("김ㅁㅁ").introduce()
└ 변수 할당 없이 클래스 바로 사용





//// 클래스 상속
└ 상속이 필요한 경우
	└	기존 클래스를 확장해 기능을 추가한 클래스를 만들고 싶음
	└ 기존 클래스들의 공통점을 뽑아 새로운 클래스를 만들어 코드 관리를 편하게 하고싶음

// 상속시 주의사항
└ 코틀린은 상속 금지가 디폴트임 ( open 붙이기 )
└ 서브 클래스는 수퍼 클래스에 존재하는 속성과 같은 이름의 속성을 가질 수 없음
└ 서브클래스가 생성될 때는 "반드시" 수퍼클래스의 생성자까지 호출되어야(수퍼클래스의 패러미터까지 전부 적어줘야) 함
└ 서브 클래스를 만들 때 받는 값(패러미터)에 var, val을 붙이면 클래스 자체(고유)의 속성으로 선언됨.
	└ 수퍼클래스의 속성값을 그대로 받아서 쓰려면 var, val을 제외하고 적어야 함.
└ 지나친 상속 자제

// 이하 예시

fun main() {
	var a = Animal("별이", 5, "개")
	var b = Dog("별이", 5)

	a.introduce()
	b.introduce() // 부모 클래스의 함수(기능)을 쓸 수 있음
	b.bark()

	var c = Cat("루이", 1)

	c.introduce()
	c.meow()
}

open class Animal(var name: String, var age: Int, var type: String) {
	fun introduce() {
		println("저는 ${type} ${name}이고, ${age}살 입니다.")
	}
}

class Dog (name: String, age: Int) : Animal(name, age, "개") {
	fun bark() {
		println("멍멍")
	}
}

class Cat (name: String, age: Int) : Animal(name, age, "고양이") {
	fun meow() {
		println("야옹")
	}
}
└ open class
	└ class 앞에 open을 붙여야 상속이 가능해짐.
└ Animal class : 수퍼클래스
└ Dog, Cat class : 서브클래스
└ bark(), meow()
	└ Dog, Cat 클래스에서 Animal을 상속받아 '새로 추가한' '기능'. 수퍼클래스인 Animal에서는 사용할 수 없음.
└ 클래스 내부에 보조생성자 만들 때처럼 상속 클래스도 뒤에 ': SuperName(param1, param2, ...)' 을 적어줘야 함.
└ 오버라이드하지 않아도 부모 변수 이름이나 함수를 그대로 사용할 수 있음(당연)





//// 오버라이딩
└ 수퍼클래스의 함수를 서브클래스에서 그대로 받되 내용을 새롭게 작성(재구현)해 사용하는 것
└ 수퍼클래스의 허용(open)이 필요함.
	└ 상속을 허용할 "함수" 앞에 open을 추가해주면 됨.
└ 서브가 여러개를 상속받는데 수퍼들 가운데 같은 이름과 형태를 가진 함수들이 있으면 서브에서는 혼선이 일어나지 않도록 반드시 오버라이딩하여 재구현해주어야 함.

fun main() {
	var p = Tiger()
	p.eat()
}

open class Animal {
	open fun eat() {
		println("음식을 먹습니다")
	}
}

class Tiger : Animal() {
	override fun eat() { 
		println("고기를 먹습니다")
	}
}
└ Animal은 상속 가능한 클래스 (오버라이딩 전 선행)
└ open fun ~ : 오버라이딩이 가능한 함수
└ override fun ~ : 오버라이딩을 통해 재구현한 함수





//// 추상화의 기본(abstract, interface 공통)
└ 추상화가 필요한 경우
	└ 추상함수를 수퍼에 작성하고 서브클래스가 이 함수를 "반드시" 구현하도록 만들고 싶을 때 추상함수 및 추상클래스 사용
└ 추상함수
	└ 형식만 선언한 함수. 구체적인 구현이 없는 함수. 빈 껍데기. 서브가 구현해야됨.
└ 추상클래스
	└ 추상클래스는 빈 껍데기를 담고 있기 때문에(미완이기 때문에) 단독으로 인스턴스를 생성할 수 없음. 상속의 형태로만 사용할 수 있음.
└ 수퍼는 추상클래스/추상함수를 상속하기 위해서 굳이 open을 안 적어도 됨. (abstract의 일반함수는 open을 적어야하는지 잘 모름)
	└ 단 서브는 뭘 받든지 상속받을 때/오버라이딩할 때의 형식을 분명히 지킬 것.
└ 추상클래스에는 일반 함수도 담을 수 있음.





//// 추상화 : abstract
└ 생성자를 가질 수 있음

fun main() {
	var a = Rabbit()
	a.eat()
	a.sniff()
}

abstract class Animal {
	abstract fun eat()
	fun sniff() {
		println("킁킁")
	}
}

class Rabbit : Animal() {
	override fun eat() {
		println("당근을 먹습니다")
	}
}
└ abstract class / abstract fun : 추상클래스 / 추상함수
└ Rabbit이 Animal의 eat()함수를 오버라이딩해 구현 및 사용한 모습





//// 추상화 : interface
└ 코틀린에서는 인터페이스도 일반 클래스와 같이 속성, 추상함수, 일반함수를 가질 수 있음.
└ 생성자를 가질 수 없음
└ 함수가 빈껍데기면 abstract, 내용이 있으면 open 함수로 간주함.
	└ 뭐든 그냥 open이라는 키워드 없이 상속할 수 있다는 뜻임.
└ 한 서브에서 여러개의 인터페이스를 상속받을 수 있음
	└ 서로 다른 기능들을 서브에 여러개 물려주어야 할 때 유용

// 이하 예시

fun main() {
	var r = Dog()
	r.run()
	r.eat()
}

interface Runner {
	fun run()
}

interface Eater {
	fun eat() {
		println("음식을 먹습니다")
	}
}

class Dog : Runner, Eater {
	override fun run() {
		println("우다다다 뜁니다")
	}
	override fun eat() {
		println("허겁지겁 먹습니다")
	}
}
└ 한 서브가 두가지 인터페이스를 상속받은 예시
└ run()은 구현부 없음, eat()은 구현부 있음.
	└ 둘 다 open같은 거 안 적혀있음 유념.
└ 서브는 override 꼬박꼬박 써준 거 유념.





//// 프로젝트 구조
└ 어플리케이션을 짤 때 관련한 모든 내용을 담는 큰 틀
└ 하나의 프로젝트는 여러개의 모듈로 이루어져 있음
└ 프로젝트, 모듈, 폴더 및 파일은 실제 파일 시스템에 기반해 프로젝트의 물리적 구조를 담당함	
└ 패키지는 프로젝트의 논리적 구조를 담당

// 모듈
└ 기능이 구현된 라이브러리 모듈 가져와서 써도 됨.
└ 직접 만들기도 가능.
└ 모듈에는 다수의 폴더와 파일이 들어갈 수 있음.
	└ 여기에는 모듈과 관련된 설정 및 리소스 파일 등도 포함될 수 있음

// 패키지
└ 개발시 소스 코드의 '소속'을 지정하기 위한 논리적 단위
└ 코드 내에서 사용하는 이름이 용도에 따라 서로 충돌하지 않도록 유니크한 패키지 이름을 지어주기.

// 패키지명 규칙
└ 1. 도메인을 거꾸로 배열
└ 2. 뒷자리에 프로젝트명을 붙임
└ 3. 그 뒷자리에 기능별로 세분화된 이름들을 붙임

// 코드파일 패키지로 묶기
└ 1. 코드 파일 맨 윗줄에 pakage를 적음
└ 2. 공백 한 칸 주고 뒷자리에 소속된(될) 패키지 이름을 적어줌.

// 기타
└ 같은 패키지 안에서는 변수 및 함수, 클래스를 공유함.
	└ 서로 '이름만' 부르면 쓸 수 있음.
└ 패키지가 다르면 import 작업을 해줘야 함.
	└ 패키지 선언 아래에 import + 외부 패키지 이름을 적어주면 다른 패키지의 요소들을 그대로 사용 가능.
	└ 참조한 패키지들끼리 요소 이름이 겹치면 각 패키지들 사용시 '패키지풀네임 + 요소이름'으로 적어야 함.





//// 스코프(Scope) - 범위. 좁게 보면 중괄호 영역.
└ 프로젝트 내에서 변수, 함수, 클래스의 공용 범위를 제어하는 단위
└ 스코프 안에 변수나 함수, 클래스를 배치할 수 있음.
└ 스코프는 패키지 내부, 클래스 내부, 함수 내부 등의 범위로 묶을 수 있음.

// 스코프 규칙
└ 스코프 외부에서는 스코프 내부의 멤버를 '참조연산자'로만 참조가 가능
	└ ex) a.eat()에서 . <- 이 점이 참조연산자
	└ 참조연산자는 패키지 명에도 사용됨.
└ 동일 스코프 내에서는 멤버들을 공유할 수 있음.
└ 하위 스코프에서는 상위 스코프의 멤버를 재정의할 수 있음.
└ 스코프의 같은 레벨에서는 같은 이름의 멤버를 만들어서는 안됨.
	└ 위 규칙 위반시 conflicting declarations(선언부 충돌) 에러남.


// 패키지 스코프 예시

fun main() {
	val a = "함수 스코프"
	println(a)
	B().print()
}

val a = "패키지 스코프"

class B {
	fun print() {
		val a = "클래스 스코프"
	println(a)
	}
}
└ 동일 스코프(패키지 스코프) 내에서 멤버를 공유하는 예시.
└ 상단에 패키지명이 없기 때문에 예시의 모든 데이터는 default 패키지에 소속됨.
	└ 예시의 변수, 함수, 클래스는 전부 같은 패키지 스코프 안에 있음을 의미함.
	└ 예시의 함수와 클래스 역시 각각의 스코프를 가지고 있음.
		└ 함수와 클래스 스코프는 패키지의 하위 스코프가 됨.
└ 각 클래스와 함수에 'val a'가 없을 땐 패키지 스코프의 'val a'를 공유하지만 각각의 스코프가 'val a'값을 갖게 되면 자신의 스코프 값을 우선 참조함.
	└ 하위 스코프가 상위 스코프의 멤버를 재정의하여 사용할 수 있음을 증명하는 예시





//// 접근제한자
└ 스코프 외부에서 스코프 내부로 접근하는 것을 개발자가 제어할 수 있음
└ 변수, 함수, 클래스 선언시 맨 앞에 붙여 사용함

// 패키지 스코프의 접근 제한자

public : 어떤 패키지에서도 접근 가능 (기본값)
internal : 같은 모듈 내에서만 접근 가능
private : 같은 파일 내에서만 접근 가능
패키지 스코프에서 protected는 사용 안함

// 클래스 스코프의 접근 제한자

public : 클래스 외부에서 늘 접근 가능 (기본값)
private : 클래스 내부에서만 접근 가능
protected : 클래스 자신과 상속받은 클래스에서만 접근 가능
클래스 스코프에서 internal은 사용 안함





//// 고차함수
└ 일반함수를 고차함수로 만들면 패러미터로 넘겨줄 수도 있고 리턴값으로 반환받을 수도 있음.
└ 모든 함수를 고차 함수로 사용 가능함.
└ 당연히 일반 함수처럼 여러 구문의 사용이 가능함

// 고차함수로 패러미터 받기

 fun b (function: (String)->Unit){ 
     function("b가 호출한")
 }
└ (String) -> Unit
	└ ★람다식 함수 "자료형". 이거 자체가 하나의 자료형이 됨.
	└ (이 함수가 받는 패러미터의 자료형) -> 이 함수가 리턴하는 값의 자료형
	└ 패러미터 추가는 (A, B, C) 이렇게 콤마로 나눠 적으면 됨
	└ 이 (함수) 자료형과 일치하는 함수를 매개변수로 받을 수 있음.
	└ ★Unit : 반환할 값 없음
└ function
	└ 이 고차함수 자료형의 변수 이름 예시
	└ 여기에 a()함수를 받으면 이 변수 이름에 a가 대입된다고 생각하면 됨.

// 일반 함수를 패러미터로 보내기

b(::a)
└ 일반함수 a 앞에 ::연산자를 붙여주면 일반 함수가 고차 함수로 변경되고 '함수 자료형'을 받는 함수에 파라미터로 보낼 수 있게 됨.
└ 함수 b 안에서 (String)->Unit 유형의 함수 a를 호출한 것과 같음.

// 이하 예시

fun main() {
 	b(::a)
 }

 fun a (str: String) {
     println("$str 함수 a")
 }

 fun b (function: (String)->Unit){ 
     function("b가 호출한")
 }





//// 람다함수
└ 람다함수 자체가 고차함수임.
└ 그러므로 일반함수와 달리 :: 없이도 패러미터에 담을 수 있음.

// 람다함수 만들기 + 변수에 할당

var c: (String)->Unit = {str -> println("$str 람다함수")}
└ = {} 부분이 실제로 동작할 람다함수(기능) 부분
	└ {} 안에도 람다식으로 쓴다. 
		└ { 파라미터(변수)이름 -> 구현부분 }
		└ 받을 파라미터가 없는 경우 자료형은 ()로만 입력, 스코프 내부는 '변수 ->' 생략
└ str은 자료형이 String으로 지정된 패러미터 변수 이름
	└ 자바식으로 쓰면 "String str"
└ 스코프 내부도 {str: String -> ~}로 자료형을 적어주는 것이 기본이지만, 예시에서는 앞의 () 안에 이미 String이 기술되어 있으므로 코틀린이 알아서 str을 String으로 인식하기 때문에 안 적어줘도 됨.

// 람다함수 만들기 + 변수에 할당 (타입 추론으로 축약한 ver)

var c = {str: String -> println("$str 람다함수")}
└ 이렇게 만들면 입력한 함수의 형식과 맞는 함수 자료형(여기서는 '(String)->Unit') 으로 자료형이 알아서 저장됨.

// 이하 예시

fun main() {
	var c: (String)->Unit = {str -> println("$str 람다함수")}
	// var c = {str: String -> println("$str 람다함수")}

	b(c)
}

fun b (function: (String)->Unit){
	function("b가 호출한")
}
└ 변수 c는 람다함수로 만들어져있고, 람다함수는 그 자체로 고차함수이기 때문에 앞에 ::을 붙일 필요가 없다.





//// 고차함수 & 람다함수 요약
└ 컬렉션의 조작이나 스코프 함수의 사용에 도움이 됨.





//// 스코프 함수
└ 함수형 언어의 특징을 편리하게 사용할 수 있도록 기본 제공하는 함수.
└ 그냥 내 생각에 중괄호를 써서 스코프 함수인 거 같음.
└ 인스턴스를 스코프 함수에 전달하면 인스턴스의 속성과 함수를 깔끔하게 불러서 쓸 수 있음.
	└ 코드의 가독성 향상 효과

// 객체.apply { }
└ ★보통 인스턴스를 생성할 때 같이 씀.
└ 구문 처리 후 객체(자기 자신)를 리턴함.
└ 스코프 안에서 참조연산자 없이 패러미터(변수) 사용이 가능.

// ★객체.also { }
└ .apply { } 와 기능이 같음.
└ 외부 스코프와 내부 스코프를 'it.변수이름'으로 구분함
	└ 내부 스코프에 it을 붙임.

// 객체변수.run { }
└ 당연히 변수 대신 객체를 바로 대입할 수 있음.
└ 최종값(스코프 내부 마지막 구문의 결과값)을 반환함.
└ 스코프 안에서 참조연산자 없이 패러미터(변수) 사용이 가능.

// ★객체변수.let { }
└ 당연히 변수 대신 객체를 바로 대입할 수 있음.
└ .run { } 과 기능이 같음.
└ 외부 스코프와 내부 스코프를 'it.변수이름'으로 구분함
	└ 내부 스코프에 it을 붙임.

// with(객체변수) { }
└ 당연히 변수 대신 객체를 바로 대입할 수 있음.
└ .run { } 과 기능이 같음.

// 예시

fun main() {
	// also/let
	var price = 5000

	// apply
	var a = Book("디모의 코틀린", 10000).apply {
		name = "[초특가]" + name
		discount()
	}

	// .apply { } 사용 전 기존 변환 방법
	// a.name = "[초특가]" + a.name
	// a.discount()

	// // run 1
	// var b = a.run {
	//     println(a.price)
	//     a.name
	// }

	// run 2
	a.run {
		println("상품명: ${name}, 가격: ${price}원")
	}

	// with : run과 동일한 기능을 가짐
	with(a) {
		println("상품명: ${name}, 가격: ${price}원")
	}

	// also/let
	a.let {
		println("상품명: ${it.name}, 가격: ${it.price}원")
	}
}

class Book(var name: String, var price: Int) {
	fun discount(){
		price -= 2000 // price에서 -2000을 한 값을 반환
	}
}
└ Book("디모의 코틀린", 10000).apply { }
	└ 적절한 예는 아니지만 a.apply { ~ }로 사용한 것과 같다.
	└ 중괄호 영역을 스코프라고 부르는 것 잊지 말기.
	└ apply는 인스턴스 자신을 반환하므로 위 예시처럼 '생성하자마자 조작하려는 값'을 인스턴스 변수에 바로 넣을 수 있음.
└ run 1
	└ 가격은 출력하고 a.name은 반환되어 변수 b에 할당된다.
└ run 2
	└ 반환값 없이 그냥 사용하는 run
└ price -= 2000
	└ price에서 -2000을 한 값을 반환





//// 오브젝트 : Object
└ 단 하나의 객체만 생성하여 공통적인 속성과 함수를 사용하는 것이 효율적일 때 class 대신 오브젝트를 사용함.
└ 싱글톤 패턴을 지원함.
	└ 싱글톤 패턴 : 인스턴스를 하나만 만들어 사용하도록 하는 코딩 아키텍쳐 패턴

// 오브젝트 특징
└ 그 자체로 '객체'이며 인스턴스를 생성하지 않음.
	└ 때문에 생성자도 사용하지 않음.
└ 인스턴스를 생성하지 않기 때문에 오브젝트의 이름에 바로 참조연산자를 붙여 오브젝트를 호출함.
	└ ex) Counter.count
	└ 클래스의 실행(ex. Counter().count)과 문법이 다른 점 유의.
└ 오브젝트 객체는 외부에서 최초 '사용'시 자동으로 생성됨
	└ 생성부터 코드 전체에서 '공용으로 사용'할 수 있음
	└ 그러므로 오브젝트는 프로그램이 종료되기 전까지 공통적으로 사용할 내용들을 묶어서 만드는 좋음.

// 예시

fun main() {
	println(Counter.count)

	Counter.countUp()
	Counter.countUp()

	println(Counter.count)

	Counter.clear()

	println(Counter.count)
}

object Counter {
	var count = 0

	fun countUp() {
		count++
	}

	fun clear() {
		count = 0
	}
}





//// Companion Object
└ 클래스 내부에 생성하는 오브젝트.
└ 컴패니언 오브젝트를 가진 클래스로 외부에서 인스턴스를 여러개 생성할 때, 이 오브젝트의 내용은 해당 클래스로 만든 인스턴스 모두가 공통으로 공유함.
└ ★자바의 Static 멤버와 비슷함.
	└ Static 멤버 : 클래스 내부에서 별도의 영역에 고정적으로 존재하여 "인스턴스를 생성하지 않아도" "공용으로 사용 가능한" 속성이나 함수

// 예시

fun main() {
	var a = FoodPoll("짜장")
	var b = FoodPoll("짬뽕")

	a.vote()
	a.vote()

	b.vote()
	b.vote()
	b.vote()

	println("${a.name} : ${a.count}")
	println("${b.name} : ${b.count}")
	println("총계 : ${FoodPoll.total}")
}

class FoodPoll (val name: String) {
	companion object {
		var total = 0
	}

	var count = 0

	fun vote() {
		total++
		count++
	}
}
└ a의 count는 2, b의 count는 3.
└ FoodPool 클래스의 '공통 오브젝트' 내에 있는 total 변수는 a와 b가 총 5번 호출되는 동안 총 다섯번이 더해져서 2+3 = 5가 됨.
└ println("총계 : ${FoodPoll.total}")
	└ 오브젝트는 오브젝트명 자체로 불러내는 것과 같이, 여기서는 object가 속한 클래스명 뒤에 참조연산자를 붙여 total을 불러냄.





//// 옵저버 패턴 : Observer Pattern
'이벤트가 발생할 때마다' '즉각적으로 처리'할 수 있도록 만드는 프로그래밍 패턴

// 옵저버
└ 이벤트가 일어나는 것을 감시하는 감시자의 역할
	└ ex) 키가 입력될 때, 터치가 발생할 때, 데이터가 수신됨 등등

// 이벤트
└ 함수로 직접 요청하지 않았지만 시스템 또는 루틴에 의해서 발생하게 되는 동작들

// Callback(콜백) : 옵저버 패턴의 구현 방식 중 하나
└ 다른 함수에 '매개변수로 함수를 전달'하고, 어떠한 이벤트가 발생한 후 '매개변수로 전달한 함수가 다시 호출'되는 과정
└ 어떤 일을 다른 객체에게 시키고, 그 일이 끝나는 것은 기다리지 않고 끝나고 부를 때까지 자신은 다른 일을 하는 것.
	└ 그렇기 때문에 non-block이며, 비동기 방식의 함수를 사용함.

// 옵저버 패턴에서 구현해야 하는 세가지 (메인 함수는 별개임)

1. 콜백 함수를 '정의'하는 인터페이스 (옵저버, 리스너)

interface EventListener {
	fun onEvent(count: Int)
}
└ 리스너를 통해 이벤트를 반환(리턴)하는 함수 이름은 관례적으로 이름 앞에 'on(행위)'을 붙인다는 규칙을 따른다

2. 이벤트를 발생시키고 이를 알려주는 클래스

class Counter(var listener: EventListener) {
	fun count() {
		for(i in 1..100) {
			if(i % 5 == 0) listener.onEvent(i)
		}
	}
}
└ if(i % 5 == 0) listener.onEvent(i)
	└ 강의 영상의 "클릭되면(if(i % 5 == 0)) 종(listener)을 울리겠습니다(.onEvent(i))" 이다. A가 만들어준(보낸) 종을 다시 A에게 울려준다(돌려준다)는 의미이다.

3.1. 이벤트를 수신하는(콜백을 주고받는) 클래스 - 작성 방법 1

class EventPrinter: EventListener {
	override fun onEvent(count: Int) {
		print("${count}-")
	}

	fun start() {
		val counter = Counter(this) 
		counter.count()
	}
}
└ override fun onEvent(count: Int) { ~ }
	└ 강의 예시에서 영상에서 "종은 내가 만들어두마."이다. 
└ val counter = Counter(this) 
	└ ★this는 EventPrinter를 나타내지만, 받는 쪽에서는 EventListener만 요구했기 때문에 EventPrinter가 가지고 있는 "EventListener"의 구현부(onEvent(~))만 넘겨주게 된다. => 객체지향의 다형성
└ counter.count()
	└ 강의 예시로 빗대자면 "Counter 와 봐라. 내가 만든 종 줄테니까 내가 너한테 count() 시키면 이 종을 때에 맞춰 울려줘라."
	└ EventPrinter로부터 리스너의 구현부를 넘겨받은 Count(~) 인스턴스로 count()를 실행하면 EventPrinter가 구현한 listener.onEvent(i)가 실행되어 다시 EventPrinter로 돌아온다.

3.2. 이벤트를 수신하는(콜백을 주고받는) 클래스 - 작성 방법 2 - 익명 객체(익명 오브젝트) 활용

class EventPrinter {
	fun start() {
		val counter = Counter(object: EventListener {
				override fun onEvent(count: Int) {
				print("${count}-")
			}
		})
		counter.count()
	}
}
└ interface를 상속받지 않고 '익명 객체'를 사용해 바로 EventListener를 만들어 넘겨주는 예시.
└ val counter = Counter(object: EventListener { ~ })
	└ ★★★★파라미터에 EventListener를 상속받는(: EventListener) "이름 없는 객체(object)"를 만들고 이 안에서 onEvent(~)를 override해 기능을 작성함.
	└ 이 익명의 객체를 Counter에 넘겨준 값을 counter 변수에 저장, counter.count()를 하면 'override한 다음 넘겼던' onEvent(~)가 같이 실행된다.
	└ 이렇게 익명 객체를 넘기는 방식으로 코드를 작성하면, (리스너의 콜백함수를 사용하려는) 클래스가 인터페이스를 상속받지 않고도 객체와 객체 내부를 바로 구현한 다음 패러미터로 즉시 넘길 수 있음.

// 위 과정들을 하나로 묶은 예시 (main() 포함, 3은 3.2 사용)

fun main() {
    EventPrinter().start()
}

interface EventListener {
    fun onEvent(count: Int)
}

class Counter(var listener: EventListener) {
    fun count() { 
        for(i in 1..100) {
            if(i % 5 == 0) listener.onEvent(i)
        }
    }
}

class EventPrinter {
    fun start() {
        val counter = Counter(object: EventListener { 
            override fun onEvent(count: Int) {
            print("${count}-")
        	}
        })
        counter.count()
    }
}
└ 최종적으로 main()에서 쓰는 객체는 EventPrinter이다.





//// 클래스의 다형성(업캐스팅, 다운캐스팅)
└ 클래스의 다형성
	└ 클래스의 상속 관계에서 오는 인스턴스의 호환성
└ 업캐스팅/다운캐스팅은 위 특징을 적극적으로 활용할 수 있는 기능들이다.
└ 수퍼클래스가 같은 인스턴스를 한번에 관리해야 할 때나, 인터페이스를 구현하여 사용하는 코드에서 이용한다.

// 업캐스팅
서브클래스를 수퍼클래스에 담는 것
ex) var b: Drink = Cola()
└ b는 Cola()가 상속받은 "자신의 영역만 사용할 수 있다."

// 다운캐스팅
업캐스팅된 인스턴스를 다시 본래의 서브클래스로 변환하는 것
ex) if(b is Cola) { 구문 }
└ is : 전자가 후자의 클래스와 호환하는지를 체크해 논리형을 반환하는 연산자
└ b가 Cola 클래스를 호환하면 구문을 실행한다.
└ 이 때 구문 안에서 b는 "잠시" Cola 클래스로 다운캐스팅한다.
ex) var c = b as Cola
└ as : 전자가 후자의 클래스를 호환하면 b를 다운캐스팅한다.
└ b가 Cola 클래스를 호환하면 b를 다운캐스팅해서 c에 담는다.
└ ★★★이 때 b도 함께 다운캐스팅이 된다.

// 예시

fun main() {
    var a = Drink()
    a.drink()
   
    var b: Drink = Cola()
    b.drink()
//     b.washDishes()
   
    // is 예시
    if(b is Cola) {
        b.washDishes()
    }
   
    var c = b as Cola 
    c.washDishes() 
    b.washDishes()
}

open class Drink {
    var name = "음료"
    
    open fun drink() {
        println("${name}를 마십니다")
    }
}

class Cola: Drink() {
    var type = "콜라"
 
    override fun drink() {
        println("${name}중에 ${type}를 마십니다")
    }
 
    fun washDishes() {
        println("${type}로 설거지를 합니다")
    }
}
└ 제일 첫 b.washDishes()는 오류남.
	└ b는 자신(Drink)의 영역만 쓸 수 있기 때문.
└ if(b is Cola) { b.washDishes() }
	└ b가 Cola와 호환이 되면 중괄호 영역 안에서는 b를 Cola로 바꿔주기 때문에 이 코드는 오류 없이 실행된다.
└ c.washDishes()
	└ 다운캐스팅했기 때문에 이 코드 역시 잘 실행됨.
	└ 이 코드 아래의 b.washDishes()도 역시 잘 실행됨. var c = b as Cola를 할 때 반환값이 var c에만 할당되는 것이 아니라 b에도 다운캐스팅이 적용되기 때문임.





//// 제너릭 (Generic) - <T>
└ 제너릭을 사용하면 클래스나 함수에서 사용하는 ★★★"자료형을 외부에서 지정할 수 있음."★★★
└ 클래스나 함수를 선언할 때 '고정적인 자료형 대신' 실제 자료형으로 '대체되는 타입 패러미터를 받아' 사용하는 방법
└ 업캐스팅, 다운캐스팅 없이도 다형성의 장점을 활용할 수 있음.
	└ 자료형을 '있는 그대로' 사용할 수 있음.

// 제너릭 공통 규칙
└ 제너릭 안에 들어가는 타입 패러미터의 이름은 클래스 이름과 규칙이 같지만 일반적으로 Type의 이니셜인 T를 사용하는 것이 관례
	└ 여러개의 제너릭을 사용할 경우 T의 다음 알파벳인 U와 V를 추가적으로 사용
└ ★★★★제너릭을 특정한 수퍼클래스를 상속받은 클래스 타입으로만 제한하려면 콜론 뒤에 특정 수퍼클래스 이름을 적어주면 된다.
	└ ex) <T: SuperClass>

// 펑션 제너릭
└ 함수에 제너릭을 사용한 경우 일반적인 함수처럼 사용하면 패러미터나 반환형을 통해 타입 패러미터를 자동으로 추론함.
	└ ex) fun <T> genericFunc (var param: T) {}일 때 genericFunc(1)을 쓰면 프로그램은 T를 Int로 추론

// 클래스 제너릭
└ 클래스에 제너릭을 써서 만든 경우 이 클래스의 인스턴스를 만들 때 타입 패러미터를 수동으로 지정해줄 수 있음
	└ ex) class GenericClass <T> { }일 때 선언시 GenericClass<Int> ()처럼 자료형을 지정해 인스턴스를 만들 수 있음
└ 클래스의 생성자에 제너릭을 사용한 경우 이 클래스의 인스턴스를 만들 때 데이터타입을 반드시 지정(<Int> 등)해주지 않아도 입력된 데이터 타입을 자동으로 추론해줌.
	└ ex) class GenericClass <T> (var pref: T)일 때 GenericClass(1)라고 쓰면 T의 타입이 추론되므로, 반드시 GenericClass<Int>(1)이라고 써주지 않아도 됨.

// 예시

fun main() {
    // 클래스 제너릭
    UsingGeneric(A()).doShouting()
    UsingGeneric(B()).doShouting()
    UsingGeneric(C()).doShouting()
    
    // 펑션 제너릭
    doShouting(B())
}

// 펑션 제너릭
fun <T: A> doShouting(t:T) {
    t.shout()
}

open class A {
    open fun shout() {
        println("A가 소리칩니다")
    }
}

class B: A() {
    override fun shout() {
        println("B가 소리칩니다")
    }
}

class C: A() {
    override fun shout() {
        println("C가 소리칩니다")
    }
}

// 클래스 제너릭
class UsingGeneric<T: A> (val t: T) {
    fun doShouting() {
        t.shout()
    }
}
└ UsingGeneric(A()).doShouting() 
	└ UsingGeneric에 클래스 'A의 인스턴스'를 넘겨줌
	└ UsingGeneric<A>(A()).doShouting() 
		└ 이렇게 타입 패러미터(<T>)를 수동으로 전달(입력)할 수도 있지만 생성자의 패러미터를 통해 클래스 A라는 것을 추론할 수 있기 때문에 이 상황에서는 생략해도 괜찮음.
└ doShouting(B())
    └ B의 객체 그대로 함수에서 사용한다.
    └ 함수 역시 제너릭의 타입을 자동으로 추론하므로 별도로 타입 패러미터(<T>)에 자료형(B)을 전달할 필요는 없다.
└ fun <T: A> doShouting(t:T) { }
	└ '클래스 A를 상속받는 T'에 맞는 t를 패러미터로 받는다.
└ class UsingGeneric<T: A> (val t: T) { }
	└ 'A를 상속받는 제너릭 T에 맞는' 속성을 속성 t로 받는다.
    └ class UsingGeneric(val t: A)로 만들어도 기능은 같지만 제너릭을 사용하는 경우 제너릭이 자료형을 대체하게 되어 캐스팅을 방지할 수 있으므로 성능을 더 높일 수 있다.





//// List<out T>, MutableList<T>
└ 데이터를 코드에서 지정한 순서대로 저장해두는 기능을 가짐
	└ 여러개의 데이터를 원하는 순서대로 넣어 관리하는 형태
└ List는 컬렉션 클래스를 상속받는 세가지 클래스들 중 가장 단순한 형태이다.

// 컬렉션 클래스
└ 데이터를 모아 관리하는 클래스
└ 여러개의 객체를 담을 수 있는 클래스들의 공통 기능들이 구현되어있음

// List<out T>
└ 생성시에 넣은 객체를 대체, 추가, 삭제할 수 없음
└ List를 만들 때는 전용 함수인 listOf(1, 2, 3)을 사용

// MutableList<T>
└ Mutable : 변할 수 있는
└ 생성시에 넣은 객체를 대체, 추가, 삭제할 수 있음
└ MutableList를 만들 때는 전용 함수인 mutableListOf(1, 2, 3)을 사용

// MutableList<T>에 사용하는 함수

.add(데이터)
└ 데이터 객체를 추가

.add(인덱스, 데이터)
└ 특정 인덱스 자리에 데이터를 추가
└ 지정한 인덱스 자리에 있던 요소와 그 다음의 모든 요소들은 한칸씩 뒤로 밀림.

.remove(데이터)
└ 데이터 삭제 방법 1

.removeAt(인덱스)
└ 데이터 삭제 방법 2

.shuffle()
└ 데이터 저장 순서 무작위 섞기

.sort()
└ 데이터 정렬

mutableList[0] = 데이터
└ 데이터 변경(대체)

// 예시

fun main() {
    // List 예시
    val a = listOf("사과", "딸기", "배")
    println(a[1])
    
    for(fruit in a) {
        print("${fruit} : ")
    }
    
    println()
    
    // MutableList 예시
    var b = mutableListOf(6, 3, 1)
    println(b)
    
    // 추가 : 일반 추가
    b.add(4)
    println(b)
    
    // 추가 : 밀어내기식
    b.add(2, 8)
    println(b)
    
    // 삭제 : 인덱스 삭제
    b.removeAt(1)
    println(b)
    
    // 무작위 섞기
    b.shuffle()
    println(b)
    
    // 정렬
    b.sort()
    println(b)
}
└ println(a[1])
	└ 배열과 사용 방법이 같음
└ for(fruit in a) { ~ }
	└ 리스트 a에서 요소를 하나씩 꺼내 fruit에 할당해줌.
└ b.add(4)
	└ 마지막 자리에 4를 추가
└ b.add(2, 8)
	└ 인덱스 2의 자리에 8을 추가
		└ 인덱스 2 자리 뒤의 요소들은 한 자리씩 뒤로 밀려남
└ b.removeAt(1)
	└ 인덱스 1의 자리를 삭제





//// 문자열 다루기 (예시 중심)

fun main() {
    val test1 = "Test.Kotlin.String"
    // 문자열 길이 구하기
    println(test1.length)
    // 문자열 전부 소문자로 만들기
    println(test1.toLowerCase())
    // 문자열 전부 대문자로 만들기
    println(test1.toUpperCase())
    
    // 문자열 나누기
    val test2 = test1.split(".")
	// test2는 배열 타입이 됨.
	// 문자열을 나누는 기준(여기서는 .)은 delimiter라고 부름.
	// 코틀린에서는 split()에 정규식이 아닌 일반 문자열을 넣어도 동작함.
    println(test2)
    
    // 나눈 문자열 배열 다시 붙이기 1 => 이렇게 붙이면 중간에 뭐 없이 그냥 다 붙여짐
    println(test2.joinToString())
    // 나눈 문자열 배열 다시 붙이기 2 => 이렇게 붙이면 붙이는 문자열 사이에 -가 추가됨
    println(test2.joinToString("-"))
    // 문자열 일부만 사용하기
    println(test1.substring(5..10))
    // ..은 IntRange, 인티저레인지라고 부름.
    // 인덱스 5부터 인덱스 10자리까지의 문자열을 리턴함.
    
    val nullString: String? = null
    val emptyString = ""
    val blankString = " "
    val nomalString = "A"
    // isNullOrEmpty() (논리형 리턴)
    println(nullString.isNullOrEmpty()) // true
    println(emptyString.isNullOrEmpty()) // true
    println(blankString.isNullOrEmpty()) // false
    println(nomalString.isNullOrEmpty()) // false
    
    println()
    
    // isNullOrBlank() (논리형 리턴)
    // 공백문자로만 이루어진 Blank상태도 비어있는 것으로 본다
	// 즉, 비어있다고 보는 범위가 isNullOrEmpty()보다 더 넓다.
    // 공백 문자에는 눈에 직접적으로 보이지 않는 문자들을 전부 포함한다.
    // ex) Space, tab, Line Feed, Carrige Return, ...
    println(nullString.isNullOrBlank()) // true
    println(emptyString.isNullOrBlank()) // true
    println(blankString.isNullOrBlank()) // true
    println(nomalString.isNullOrBlank()) // false
    
    val test3 = "kotlin.kt"
    val test4 = "java.java"
    
    // ~로 시작하는 문자열 찾기(논리형 리턴)
    println(test3.startsWith("java")) // false
    println(test4.startsWith("java")) // true
    
    // ~로 끝나는 문자열 찾기(논리형 리턴)
    println(test3.endsWith(".kt")) // true
    println(test4.endsWith(".kt")) // false
    
    // ~이 포함된 문자열 찾기(논리형 리턴)
    println(test3.contains("lin")) // true
    println(test4.contains("lin")) // false
}





//// nullable 변수에서 null값을 처리하는 방법
└ null 체크를 하기 위해 일일히 if문으로 조건을 체크하는 대신 좀 더 편리한 방법을 사용할 수 있음.

*이하 nullAble은 null이 가능한 객체/객체변수를 지칭함.

// nullAble?.~()
└ ?. (null safe operator)
	└ 참조연산자를 실행하기 전에 객체가 null인지 확인부터하고 객체가 null이면 뒤따라오는 구문을 실행시키지 않는 연산자

// nullAble?:"A".~()
└ ?: (elvis operator)
	└ 객체가 null이 아니면 객체의 값을 참조하지만 객체가 null이면 연산자 우측의 값(객체)로 대체되는 연산자

// nullAble!!.~()
└ !!. (non-null assertion operator)
	└ 참조연산자를 사용할 때 null 여부를 컴파일시 확인하지 않도록 하여 런타임이 null pointer exception이 나도록 의도적으로 방치하는 연산자

// if(nullAble != null) 대신 nullAble?.run { }으로 null 체크
null safe 연산자(?.)와 스코프 함수(run, let, with())를 같이 사용하면, null인 경우엔 스코프 함수를 실행하지 않게 되어 if()로 null을 확인하는 것을 대체할 수 있음.

// 예시

fun main() {
    var a: String? = null
    
    // ?. (null safe operator)
    println(a?.toUpperCase())
    // ?:"" (elvis operator)
    println(a?:"default".toUpperCase())
    // !!. (non-null assertion operator)예시
//     println(a!!.toUpperCase())
    
    // ★★★★ null safe + scope function (if를 대체함)
    a?.run { 
        println(toUpperCase())
        println(toLowerCase())
    }
}
└ println(a?.toUpperCase())
	└ 변수의 내용이 null이기 때문에 .toUpperCase()가 실행되지 않고, a가 null이라는 내용만 출력함.
└ println(a?:"default".toUpperCase())
	└ a가 null이면 default로 대체된다.
└ println(a!!.toUpperCase())
	└ a가 null이기 때문에 널 포인터 익셉션 발생.
└ a?.run { ~ }
	└ a가 null이면 run 함수 자체가 실행되지 않고, null이 아니면 전부 실행됨.





//// 변수 사이의 동일성

// 내용의 동일성

메모리상의 서로 다른 곳에 할당된 객체라고 해도 그 내용이 같으면 동일하다고 판단하는 것
└ ex) var a = "사이다"
		 var b = "사이다" 일 때 a와 b는 같다고 보는 것

내용의 동일성을 판단하는 연산자
└ a == b

내용의 동일성은 Any 클래스의 equals() 함수가 반환하는 Boolean값으로 판단한다.

기본 자료형들은 equals()가 이미 구현되어있으므로 별도로 구현할 필요가 없음.

커스텀 클래스에서 내용의 동일성을 확인하려면 equals()를 상속받아 동일성을 확인하는 구문을 별도로 구현해야 한다.
└ 상속받아야 하는 함수
	└ open fun equals(other: Any?): Boolean

// 객체의 동일성

서로 다른 변수가 "메모리상"의 같은 객체를 가리키고 있을 때만 동일하다고 판단하는 것

★객체의 동일성을 판단하는 연산자
└ a === b

// 예시

fun main() {
    var a = Product("콜라", 1000)
    var b = Product("콜라", 1000)
    var c = a
    var d = Product("사이다", 1000)
 
    println(a == b) // true
    println(a === b) // false
 
    println(a == c) // true
    println(a === c) // true
 
    println(a == d) // false
    println(a === d) // false
}

class Product(val name: String, val price: Int) {
    
    override fun equals(other: Any?): Boolean { 

        if(other is Product) {
            return other.name == name && other.price == price
        } else {
            return false
        }
    }
}
└ 여기서 .equals()는 ==로 사용할 수 있다.
└ 이 예시에서 other: Any?로 받는 값들은 b, c, d가 된다.
└ if(other is Product) { }
	└ b, c, d가 Product이면 내부 속성들의 내용이 같은지를 비교하는 비교식을 스코프 내부에 작성한다.





//// 오버로딩
└ 같은 스코프 안에서 같은 이름의 함수를 여러개 만들 수 있는 기능.

// 성립하지 않는 오버로딩 예시

fun main() {
	fun a(x: Int, y: Int)
	fun b(z: Int, w: Int)
}

// 예시

fun main() {
    read(7)
    read("감사합니다")
}

fun read(x: Int) {
    println("숫자 $x 입니다")
}

fun read(x: String) {
    println(x)
}





//// 함수의 argument

// default arguments
└ 클래스 및 함수의 기본값을 지정해야 할 때 사용하는 argument

// named arguments
└ '디폴트값이 지정된' 패러미터를 건너뛰고 다음(이상) 순서의 패러미터 값을 보내고 싶을 때 사용하는 argument
└ 패러미터의 '순서와 관계없이' 패러미터의 이름을 사용하여 직접 패러미터의 값을 할당하는 기능이다.

// 예시

fun main() {
    // default arguments
    deliveryItem("짬뽕")
    deliveryItem("책", 3)
    deliveryItem("노트북", 30, "학교")
	
    // named arguments
    deliveryItem("선물", destination = "친구집") 
}

fun deliveryItem(name: String, count: Int = 1, destination: String = "집") {
    println("${name} ${count}개를 ${destination}에 배달하였습니다")
}
└ 예시에서 제시된 함수의 3가지 패러미터중 기본값(변수: 자료형 = 기본값)이 지정된 패러미터는, 인스턴스 생성시 미입력해도 에러를 내지 않고 기본값을 참조함
	└ 이게 default argument의 활용임.
└ deliveryItem("짬뽕")
	└ 나머지 값은 자동으로 1, "집"이 된다.
└ deliveryItem("책", 3)
	└ 나머지 값은 자동으로 "집"이 된다.
└ deliveryItem("노트북", 30, "학교")
	└ 파라미터의 모든 값을 직접 기입한다(디폴트 값을 사용하지 않음).
└ deliveryItem("선물", destination = "친구집") 
	└ "선물"은 당연히 첫번째 패러미터에 할당되지만, "친구집"은 앞에 붙여놓은 변수명(destination)에 해당하는 자리에 할당된다.
	└ count는 입력되지 않았으므로 default arguments에 의해 디폴트 값으로 자동으로 입력된다.





//// vararg - variable number of arguments
└ 받을 패러미터들의 개수가 일정하지 않을 때 사용하는 argument
└ ★★★★ vararg는 받는 개수가 일정하지 않으므로 vararg를 사용하는 변수를 다른 패러미터와 같이 사용할 때는 반드시 맨 마지막에 붙여야 함.

// 예시

fun main() {
    sum(1, 2, 3, 4)
}

fun sum(vararg numbers: Int) { 
    var sum = 0
    
    for(n in numbers) {
        sum += n
    }
    
    println(sum)
}
└ for(n in numbers) { ~ }
	└ ★★★ vararg가 붙은 패러미터는 배열처럼 for문에 참조할 수 있다.
└ sum += n
	└ sum에 numbers로 받아온 정수값들을 전부 더해줌





//// infix 함수
└ 연산자처럼 사용할 수 있는 함수

// 예시

fun main() {

    // infix 함수 사용예 1
    println(6 multiply 4)
    
    // infix 함수 사용예 2
    println(6.multiply(4))
}

infix fun Int.multiply(x: Int): Int = this * x

└ println(6 multiply 4)
	└ 6 * 4가 됨
    └ 좌측에 붙은 6이 infix 함수가 적용되는 객체 자신. this에 해당한다.
	└ 우측에 붙은 4는 (x: Int). 즉 패러미터 값에 해당한다.
└ println(6.multiply(4))
	└ 위와 같은 결과값이 나옴.
infix fun Int.multiply(x: Int): Int = this * x
└ Int.multiply
	└ Int.는 infix 함수 multiply를 "적용"할 자료형의 이름.
		└ ★★★★ 만약 class 안에서 infix 함수를 선언할 때는 함수를 적용할 클래스가 자기 자신이므로 Int.multiply라고 적지 않고 그냥 multiply라고 적는다.
	└ '=' 뒤의 'this'의 자료형에 해당된다.
	└ multiply는 함수 이름.
└ (x: Int)
	└ 받는 패러미터 역시 Int값이다.
└ : Int
	└ 리턴값을 Int로 지정





//// 중첩클래스(Nested Class) / 내부 클래스(Inner Class)
└ 클래스간의 연계성을 표현하여 코드의 가독성 및 작성 편의성이 올라갈 수 있음

// 중첩클래스
└ 클래스 안에 클래스를 하나더 추가하는 것.
└ 중첩된 클래스가 바깥 클래스의 기능과 강하게 연관되어있다는 의미를 전달하기 위해 만들어진 형식.
└ 중첩 클래스는 외부 클래스의 내용을 공유할 수 있음.
	└ 다만 서로의 내용을 직접적으로 공유할 수 없는 별개의 클래스라는 사실을 유념할 것.

// 중첩클래스 예시

class Outer {
	class Nested {
		
	}
}
└ 인스턴스 생성 방법 - Outer.Nested()

// 내부클래스
└ 클래스 안에 클래스를 하나 더 추가하는 것
└ inner Class는 혼자서 객체를 만들 수 없고 외부 객체가 있어야만 생성 및 사용이 가능함.
└ 내부 클래스는 외부 클래스 객체의 속성이나 함수를 직접적으로 사용할 수 있음.

// 내부 클래스 예시

class Outer {
	inner class Inner {
		this@Outer
	}
}
└ 인스턴스 생성 방법 - Outer().Inner()
└ this@Outer.~
	└ 외부와 내부에서 사용하는 이름들 중 같은 이름이 있는 경우 외부 클래스를 이렇게 참조해서 구분한다.

// 예시

fun main() {
    
    // Nested Class를 호출
    Outer.Nested().introduce()
    
    // Inner Class를 호출
    val outer = Outer()
    val inner = outer.Inner()
    
    inner.introduceInner()
    inner.introduceOuter()
    
    // Outer class의 text 내용을 변경해 Inner에서 다시 호출
    outer.text = "Changed Outer Class"
    inner.introduceOuter()
}

class Outer {
    var text = "Outer Class"
 
    class Nested {
        fun introduce() {
            println("Nested Class")
        }
    }
 
    inner class Inner {
        var text = "Inner Class"
     
        fun introduceInner() {
            println(text)
        }
     
        fun introduceOuter() {
            println(this@Outer.text)
        }
    }
}





//// Data Class
└ 데이터를 다루는 데에 최적화된 클래스
└ class 앞에 data를 붙여 Data Class를 생성함.
	└ ex) data class data class Data(val name: String, val id: Int)

// Data Class에 생성되어있는 5가지 기능

1. .equals()
└ 내용의 동일성을 판단함

2. .hashcode()
└ 객체의 고유한 해시코드를 반환함

3. .toString()
└ 객체를 보기 쉽게 String으로 변환

4. .copy() / .copy(~)
└ 똑같은 내용의 새 객체를 만듦
└ 아무것도 참조하지 않으면 객체를 똑같이 복사함.
└ 참조 객체의 생성자에 담는 패러미터의 형식으로 값을 기입하면 변경된 속성을 가진 객체를 복사함.

5. .component~()
└ 속성을 순서대로 반환함.
└ 예를 들어 객체의 첫 번째 패러미터는 .component1(), 두 번째 패러미터는 .component2()가 됨.
└ 사용자가 직접 호출하기 위한 함수는 아님.

// 예시 (일반 클래스와 Data 클래스를 비교)

fun main() {

    val a = General("보영", 212)
    println(a == General("보영", 212)) // .equal() 테스트
    println(a.hashCode())
    println(a) // .toString() 테스트
    // 일반 함수는 위 기능들이 제대로 구현되지 않음
    
    println()
    
    val b = Data("루다", 306)
    println(b == Data("루다", 306)) // .equal() 테스트
    println(b.hashCode())
    println(b) // .toString() 테스트
    println(b.copy())
    println(b.copy("아린"))
    println(b.copy(id = 618))
    // 데이터 클래스는 위 기능들이 모두 유의미하게 제대로 구현됨.
    
    // data class의 component~() 예시 
    val list = listOf(Data("보영", 212), Data("루다", 306), Data("아린", 618))
	
    for((a, b) in list) { 
        println("${a}, ${b}")
    }
}

class General(val name: String, val id: Int)

data class Data(val name: String, val id: Int)

└ ★★★★ for((a, b) in list) { ~ }
	└ 리스트에 담긴 Data 객체의 내용을 for문에서 모두 순회하는 방법
	└ (a, b)
		└ 내부적으로 component1(), component2()라는 함수를 사용해 ★패러미터★ ★순서대로★ 해당 객체의 값들을 불러오게 된다.
└ println("${a}, ${b}")
	└ 각각의 데이터 객체를 위와 같이((a, b)) list에서 참조(in list)하여 내부의 속성들을 모두 출력한다.





//// Enum Class - 이니움 클래스
└ enumerated type(열거형) 클래스
└ 상태를 구분하기 위한 객체들을 이름을 붙여 여러개 생성하고, 그 중 하나의 상태를 선택하여 나타내기 위한 클래스
└ class 앞에 enum을 붙여 생성함.

// enum class 예시 1 - 기본

enum class Color {
	RED,
	BLUE,
	GREEN
}
└ ', ' 으로 상태를 구분함

// enum class 예시 2 - 속성 부여

enum class Color (val number: Int) {
	RED(1),
	BLUE(2),
	GREEN(3)
}
└ 패러미터를 받는 형식으로 각 상태에 고유한 값(속성)을 부여할 수 있다.
	└ 형식만 같고 사용법은 완전히 다름 주의.
└ 예시에서 각 상태에 대한 값(속성)을 가져오는 방법
	└ Color.RED.number

// enum class 예시 3 - 함수 추가

enum class Color (val number: Int) {
	RED(1),
	BLUE(2),
	GREEN(3);
	
	fun isRed() = this == Color.RED
}
└ GREEN(3);
	└ enum class에 함수를 추가하려면 객체의 선언이 끝나는 위치에 세미콜론(;)을 추가해 구분해야 한다.

// 예시

fun main() {
    
    var state = State.SING
    println(state)
    
    state = State.SLEEP
    println(state.isSleeping())
    
    state = State.EAT
    println(state.message)
}

enum class State(val message: String) {
    SING("노래를 부릅니다"),
    EAT("밥을 먹습니다"),
    SLEEP("잠을 잡니다");
    
    fun isSleeping() = this == State.SLEEP
}
└ State.SING
	└ enum은 선언시에 만든 객체를 이름으로 참조하여 그대로 사용한다.
└ println(state)
	└ toString()을 통해 상태 객체 이름이 그대로 출력된다
		└ 출력값 : SING
└ println(state.isSleeping())
	└ 같은 내용(message)끼리 비교했기 때문에 true를 반환
└ println(state.message)
	└ EAT의 message 속성에 담긴 "밥을 먹습니다"가 출력된다.
└ fun isSleeping() = this == State.SLEEP
	└ 비교할 대상이 State 객체 자기 자신이므로 this로 해주어야 한다.





//// Collection Class

// Set
└ 순서가 정렬되어있지 않고 중복이 허용되지 않는 컬렉션
└ 인덱스로 위치를 지정해 객체를 참조할 수 없음.
	└ .contains(~) 함수로 객체가 set 안에 존재하는지 확인한다.
└ 초기화는 setOf(a, b, c)
└ 자료형(클래스)의 모양은 Set<out T>
	└ ex) Set<Int>

// MutableSet
└ Set의 기본 기능에 객체의 추가, 삭제 기능이 추가된 컬렉션.
└ .add(데이터)로 추가, .remove(데이터)로 삭제
└ 초기화는 mutableSetOf(a, b, c)
└ 자료형(클래스)의 모양은 MutableSet<T>
	└ ex) MutableSet<Int>

// Map
└ 특정 객체를 찾아낼 수 있는 key를 해당 객체와 쌍으로 저장하는 컬렉션
└ key - 객체를 찾기 위한 값
└ value - key와 연결된 객체
└ key와 value는 MutableMap.MutableEntry의 객체로 담겨져있음.
└ 객체의 위치가 아닌 고유한 키를 통해 객체를 참조한다.
	└	ex) sampleMap["디모"]
		└ "디모"라는 key에 연결된 객체를 가져온다(참조한다)
└ 초기화는 mapOf("key" to value, "key2" to value2, ...)
└ 자료형(클래스)의 모양은 Map<K, out V>
	└ ex) Map<String, Int>

// MutableMap
└ Map의 기본 기능에 추가, 삭제 기능을 더한 컬렉션.
└ 초기화는 mutableMapOf("key" to value, "key2" to value2, ...)
└ 자료형(클래스)의 모양은 Map<K, V>
	└ ex) MutableMap<String, Int>

// MutableSet 예시

fun main() {
    val a = mutableSetOf("귤", "바나나", "키위")
    
    // 내부 요소 전부 가져오기
    for(item in a) {
        println("${item}")
    }
    
    // 추가하기
    a.add("자몽")
    println(a)
	// 리턴값 : [귤, 바나나, 키위, 자몽]
    
    // 삭제하기
    a.remove("바나나")
    println(a)
    
    // 특정 데이터가 포함되어있는지 체크하기
    println(a.contains("귤")) // return true
}

// MutableMap 예시

fun main() {
    // MutableMap 초기화
    val a = mutableMapOf("레드벨벳" to "음파음파", "트와이스" to "FANCY", "ITZY" to "ICY")
    
    for(entry in a) {
        println("${entry.key} : ${entry.value}")
    }
    
    // 추가하기
    a.put("오마이걸", "번지")
    println(a)
	// 리턴값 : {레드벨벳=음파음파, 트와이스=FANCY, ITZY=ICY, 오마이걸=번지}
    
    // 삭제하기
    a.remove("ITZY")
    println(a)
    
    // key 값으로 value 참조하기
    println(a["레드벨벳"])
}
└ "레드벨벳" to "음파음파"
	└ 초기화시 key와 value 는 to로 이어준다.
└ println("${entry.key} : ${entry.value}")
	└ MutableMap.MutableEntry 객체에 key와 value라는 속성이 들어있기 때문에 예시와 같은 방법으로 출력할 수 있다.
└ println(a["레드벨벳"])
	└ key를 어레이 혹은 리스트에서 index를 꺼내는 형태로 참조할 수 있다.





//// 컬렉션 함수 1 - 기본
└ 함수형 언어의 특징으로 좀 더 편리하게 컬렉션을 사용할 수 있음
└ 컬렉션 또는 배열에 적용할 수 있는 일반함수 또는 람다함수 형태
└ 경우에 따라 조건문과 반복문 대신 사용하면 편리함
└ 람다함수 스코프에서는 각 객체를 it으로 불러낼 수 있음.

// 예시

fun main() {
    
    val nameList = listOf("박수영", "김지수", "김다현", "신유나", "김지우")
    
	// .forEach { }
    nameList.forEach{ print(it + " ") }
    println()
    // 리턴값 : 박수영 김지수 김다현 신유나 김지우
    
	// .filter { }
    println(nameList.filter{ it.startsWith("김") })
    // 리턴값 : [김지수, 김다현, 김지우]
    
	// .map { }
    println(nameList.map{ "이름 : " + it })
    // 리턴값 : [이름 : 박수영, 이름 : 김지수, 이름 : 김다현, 이름 : 신유나, 이름 : 김지우]
    
	// .any { }
    println(nameList.any{ it == "김지연" })
    // 리턴값 : false
    
	// .all { }
    println(nameList.all{ it.length == 3 })
    // 리턴값 : true
    
	// .none { }
    println(nameList.none{ it.startsWith("이") })
    // 리턴값 : true
    
	// .first()
    println(nameList.first())
    // 리턴값 : 박수영
    
	// .first { }
    println(nameList.first{ it.startsWith("김") })
    // 리턴값 : 김지수
    
	// .last { }
    println(nameList.last{ it.startsWith("김") })
    // 리턴값 : 김지우
    
	// .count()
    println(nameList.count())
    // 리턴값 : 5
    
	// .count { }
    println(nameList.count{ it.contains("지") })
    // 리턴값 : 2
}
└ ~.forEach { ~ }
	└ 컬렉션 안에 있는 객체를 하나씩 순서대로 불러낸다. (단순 반환)
└ ~.filter { ~ }
	└ it에 조건을 걸어주면 조건에 맞는 객체만 다시 컬렉션으로 만들어 반환해준다. (조건적 반환) 
	└ 예시는 기존 값들 앞에 "이름 : "을 붙여 반환한 값을 출력한다
└ ~.map { ~ }
	└ it에 수식을 적용하면 각 객체에 적용된 값들을 다시 collection으로 반환해준다. (값 변경 후 반환)
└ ~.any { ~ }
	└ 객체들 중 '하나라도' 조건에 맞으면 true
	└ 예시는 "김지연"이 nameList에 하나라도 있으면 true를 반환
└ ~.all { ~ }
	└ 객체 '모두가' 이 조건에 맞으면 true
	└ 예시는 nameList의 모든 객체의 문자열 길이가 3인지 체크한다
└ ~.none { ~ }
	└ 객체 모두가 '하나도 조건에 맞지 않으면' true
	└ 예시는 문자열 맨 앞이 "이"로 시작되는 객체가 nameList에 "하나도 없으면" true를 반환
└ ~.first()
	└ 컬렉션의 첫번째 아이템을 반환
└ ~.first { ~ }
	└ 조건에 맞는 첫번째 아이템을 반환
	└ .find (람다)함수로 대체할 수 있다
	└ 예시는 문자열 맨 앞이 "김"으로 시작하는 객체들 중 제일 첫번째 객체의 값을 리턴한다
	└ 조건에 맞는 객체가 없는 경우(컬렉션이 비어있는 경우) NoSuchElementException 에러가 발생한다.
	└ ★★★★ 이 때는 .firstOrNull (람다)함수를 사용하면 객체가 없는 경우 null을 반환해준다.
└ ~.last { ~ }
	└ 조건에 맞는 마지막 아이템을 반환
	└ .findLast (람다)함수로 대체할 수 있다
	└ 예시는 문자열 맨 앞이 "김"으로 시작하는 객체들 중 제일 마지막 객체의 값을 리턴한다
	└ 조건에 맞는 객체가 없는 경우(컬렉션이 비어있는 경우) NoSuchElementException 에러가 발생한다.
	└ ★★★★ 이 때는 .lastOrNull (람다)함수를 사용하면 객체가 없는 경우 null을 반환해준다.
└ ~.count()
	└ 컬렉션의 모든 아이템의 개수를 반환
	└ 예시는 nameList 내부 객체들의 전체 갯수를 반환
└ ~.count { ~ }
	└ 조건에 맞는 아이템의 개수만 반환해준다.
	└ 예시는 nameList의 객체들 중 "지"가 포함된 객체의 "갯수"를 리턴한다





//// 컬렉션 함수 2-1
└ 컬렉션의 형태를 완전히 바꿔주는 컬렉션 함수들

fun main() {
    data class Person(val name: String, val birthYear: Int)
    
    val personList = listOf(Person("유나", 1992), Person("조이", 1996), Person("츄", 1999), Person("유나", 2003))
    
    // .associateBy{}
    println(personList.associateBy{ it.birthYear })
    // 결과값 : {1992=Person(name=유나, birthYear=1992), 1996=Person(name=조이, birthYear=1996), 1999=Person(name=츄, birthYear=1999), 2003=Person(name=유나, birthYear=2003)}
    
    // .groupBy{}
    println(personList.groupBy{ it.name })
    // 결과값 : {유나=[Person(name=유나, birthYear=1992), Person(name=유나, birthYear=2003)], 조이=[Person(name=조이, birthYear=1996)], 츄=[Person(name=츄, birthYear=1999)]}
    
    // .partition{}
    val (over98, under98) = personList.partition{ it.birthYear > 1998 }
    println(over98) 
	// 결과값 : [Person(name=츄, birthYear=1999), Person(name=유나, birthYear=2003)]
    println(under98) 
	// 결과값 : [Person(name=유나, birthYear=1992), Person(name=조이, birthYear=1996)]
}
└ ~.associateBy { ~ }
	└ 특정 값을 key로 지정하면, 나머지를 value로 하는 Map 타입을 반환하는 함수
	└ personList.associateBy{ it.birthYear }
		└ 예시는 Person 데이터 클래스의 birthYear를 기준으로(Key로)하고 나머지를 value로 하는 Map을 만들어준다.
└ ~.groupBy { ~ }
	└ 특정 값을 key로 지정하고, key가 같은 아이템끼리 묶은 ★★★배열을 value로 하는★★★ Map 타입을 반환하는 함수
	└ personList.groupBy{ it.name }
		└ 예시는 이름을 기준으로 묶어 Map을 만든다
└ ~.partition { ~ }
	└ 아이템에 조건을 걸어 true인지 false인지에 따라 두개의 컬렉션으로 혹은 하나의 Pair 클래스로 리턴하는 함수
	└ 나눠진 두 컬렉션을 변수 하나에 받을 경우 두 객체를 담을 수 있는 Pair라는 클래스의 객체로 반환된다.
		└ 이 때 각각의 컬렉션을 first, second로 참조하여 사용할 수 있음
	└ 변수 두개로 나눠받으면 각각의 변수에 컬렉션으로 저장된다.
	└ ★★★val (over98, under98) = personList.partition{ it.birthYear > 1998 }
		└ 예시는 birthYear값을 기준으로 1998 이상과 이하로 나눠 각각을 over98, under98에 저장한다.





//// 컬렉션 함수 2-2
└ 컬렉션의 형태를 완전히 바꿔주는 컬렉션 함수들

fun main() {
    val numbers = listOf(-3, 7, 2, -10, 1)
    
    // .flatMap{}
    println(numbers.flatMap{ listOf(it * 10, it + 10) })
    // 결과값 : [-30, 7, 70, 17, 20, 12, -100, 0, 10, 11]
    
    // .getOrElse{}
    println(numbers.getOrElse(1) {50})
    // 결과값 : 7
    println(numbers.getOrElse(10) {50})
    // 결과값 : 50
   	
    // zip
    val names = listOf("A", "B", "C", "D")
    println(names zip numbers)
    // 결과값 : [(A, -3), (B, 7), (C, 2), (D, -10)]
}
└ ~.flatMap { ~ }
	└ .map { }에서 확장된 기능
	└ 스코프 내에서 아이템으로 컬렉션을 또 만들면 그 객체들을 다시 하나의 컬렉션으로(혹은 iterable로) 합쳐서 반환
		└ flatMap 스코프 안에서 it은 반드시 두개 이상으로 나눠져야 한다.
	└ numbers.flatMap{ listOf(it * 10, it + 10) }
		└ 예시는 numbers의 아이템들에 각각 *10을 한 값, +10을 한 값을 적용한 List를 만들고, 그 값들을 순서대로 담은 새 List를 반환한다.
└ ~.getOrElse(인덱스) { 기본값 }
	└ 지정한 인덱스 위치에 아이템이 있으면 아이템을 반환, 아니면 지정한 기본값을 반환함
	└ numbers.getOrElse(1) {50}
		└ 예시는 인덱스 1에 객체가 있으면 인덱스 1의 값을 리턴, 없으면 50을 리턴
└ ~ zip ~
	└ 두 컬렉션에서 순서대로 각각 뽑아낸 객체를 1:1의 "Pair Class의 객체로 만들어" "List에 넣어" 반환해준다.
		└ 결과 List의 아이템의 개수는 더 작은 컬렉션을 따라간다.
	└ names zip numbers
		└ 예시에서 numbers의 마지막 인덱스의 값인 1은 names와 맞는 짝이 없으므로 최종 List에서 제외된다.





//// 상수 (constants)
└ 컴파일 시점에 결정되어 절대 바꿀 수 없는 값
└ 초기화 방법 예시
	└ const val CONST_A = 1234
└ 늘 고정적으로 사용할 값은 상수를 통해 '객체의 생성없이' '메모리에 값을 고정하여' 사용함으로서 성능을 향상시킬 수 있다

// 상수 규칙

String을 포함한 기본 자료형만 상수의 값으로 초기화가 가능

★★★★상수는 반드시 companion object 안에 선언해서 객체의 생성과 관계없이 클래스와 관계된 고정적인 값으로만 사용한다.

상수의 이름을 만들 때는 의례적으로 대문자와 언더바만 사용함

// 예시

fun main() {
    val foodCourt = FoodCourt()
    foodCourt.searchPrice(FoodCourt.FOOD_CREAM_PASTA)
    foodCourt.searchPrice(FoodCourt.FOOD_STEAK)
    foodCourt.searchPrice(FoodCourt.FOOD_PIZZA)
}

class FoodCourt {
 
    companion object {
        const val FOOD_CREAM_PASTA = "크림파스타"
        const val FOOD_STEAK = "스테이크"
        const val FOOD_PIZZA = "피자"
    }
    
    fun searchPrice(foodName : String) {
	
     	val price = when(foodName) {
            FOOD_CREAM_PASTA -> 13000
            FOOD_STEAK -> 25000
            FOOD_PIZZA -> 15000
            else -> 0
        }
     
        println("${foodName}의 가격은 ${price}원 입니다")
    }
}





//// lateinit (늦은 초기화)
└ 변수에 객체를 할당하는 것을 선언과 동시에 할 수 없는 경우, var 앞에 lateinit을 붙여 일단 선언만 하고 초기값 할당은 나중에 할 수 있다.

// lateinit 규칙

초기값을 할당하기 전까지는 변수를 사용할 수 없음.

String을 제외한 기본 자료형에는 lateinit을 사용할 수 없음.

// lateinit 변수가 초기화가 되었는지 확인하는 방법

확인할 lateinit 변수 앞에는 ::를, 뒤에는 .isInitialized를 붙이면 이 변수의 초기화 여부를 논리형 값으로 return한다.
└ 초기화되어있으면 true를 반환
└ ex) ::a.isInitialized

// 예시

fun main() {
    val a = LateInitSample()
    
    println(a.getLateInitText())
    
    a.text = "새로 할당한 값"
    println(a.getLateInitText())
}

class LateInitSample {
    lateinit var text: String
    
    fun getLateInitText(): String {
        if(::text.isInitialized) {
            return text
        } else {
            return "기본값"
        }
    }
}
└ if(::text.isInitialized) { ~ }
	└ text가 초기화 되어있다면 true를 반환함.
└ a.getLateInitText()
	└ 예시에서 변수가 초기화되어있지 않은 상태에서는 "기본값"을, 초기화한 상태면 "새로 할당한 값"을 return함





//// 초기화의 지연 - 지연 대리자 속성 (lazy delegate properties)
변수를 사용하는 시점까지 "자동으로" 초기화를 늦춰주는 속성
코드의 실행 시간을 최적화할 수 있는 코드이다.

// 선언/초기화 방법

var/val 변수 + : 자료형 + by + lazy {초기화값}
└ ex) val a: Int by lazy {7}
└ by 의 역할은 = 에 빗댈 수 있음.
└ lazy {}
	└ 람다함수 형태의 '초기화 함수'
	└ 람다함수로 초기화가 진행되므로 함수 안에 여러개의 구문이 들어갈 수 있음
	└ ★★★맨 마지막 구문의 결과가 변수에 할당됨★★★
└ 모양 자체는 선언 즉시 초기화하는 형태지만, 실제로는 변수를 사용하는 그 시점에 초기화 과정을 진행함.

// 예시

fun main() {
    val number: Int by lazy {
        println("초기화를 합니다")
        7
    }
    
    println("코드를 시작합니다")
    println(number)
    println(number)
}
└ println(number)
	└ 예시에서 number를 처음 사용하는 이 시점에서 number에 지정해둔 구문(lazy {~})이 실행된다
	└ number의 값은 스코프 안의 마지막 값인 7이다.
	└ 이미 이전에 초기화를 실행한 상태에서 다시 이 코드를 실행하면, ★★★초기화 구문(lazy {~})을 다시 실행하는 것이 아니라★★★ 이전에 최종적으로 초기화된 값이 출력됨을 알 수 있다.





//// 비트 연산
└ 비트 연산은 정수형 변수를 2진법인 비트 단위로 연산할 수 있는 기능

10진법 예시 : 173 (일반 숫자)
2진법 예시 : 10101101

// 비트 연산 규칙

좌측으로 갈수록 상위 비트, 우측으로 갈수록 하위 비트

코틀린은 모든 정수형이 부호(+, -)를 포함하고, 비트 단위에서 정수의 최상위 비트는 +인지 -인지를 표시하는 위치이기 때문에 이 부분에는 데이터를 담지 않는 것이 좋음.

// 실무에서의 비트 연산

정수형의 값을 비트 단위로 나누어 데이터를 좀 더 작은 단위로 담아 경제성을 높이기 위한 용도로 사용

주로 플래그 값을 처리하거나 네트워크 등에서 프로토콜의 데이터 양을 줄이기 위해 자주 사용

// 예시

예시는 example kotlin / 설명은 study kotlin 참고





//// 코루틴으로 비동기 처리하기

// 코루틴 (coroutine)
└ 자바에서는 제공되지 않는 쓰레딩 방법
└ 메인이 되는 루틴과 별도로 진행이 가능한 루틴
└ 개발자가 루틴의 실행과 종료를 마음대로 제어할 수 있는 단위
└ 코루틴을 사용해 비동기로(여러개의 루틴을 동시에) 처리할 수 있음

// 코루틴 사용 전 import
└ import kotlinx.coroutines.*

// 코루틴의 Scope
└ 코루틴은 Scope에서 제어할 수 있음.
	└ 스코프에서 제어 범위 및 실행 범위를 지정할 수 있음

LifecycleScope
└ ???

GlobalScope
└ 프로그램의 어디서나 제어, 동작이 가능한 코루틴 기본 범위
└ Application이 종료될 때 까지 코루틴을 실행시킬 수 있음.
	└ 만약 Activity에서 GlobalScope영역으로 코루틴을 실행시켰다면, Activity가 종료되도 코루틴은 작업이 끝날 때까지 동작함

CoroutineScope
└ 특정한 목적의 Dispatcher를 지정하여 제어 및 동작이 가능한 새로운 코루틴의 범위를 생성한다

// CoroutineScope 인스턴스를 만들 때 적용가능한 Dispatcher
└ 적용 가능한 'Thread'
└ 디스패처들은 모든 플랫폼에서 지원되지는 않는다.
	└ 따라서 지원되는 플랫폼에 맞게 사용해야 함.

Dispatcher.Default
└ 백그라운드에서 동작하는 디스패처(기본적인 백그라운드 동작)

Dispatchers.IO
└ Disk 또는 네트워크에서 데이터 읽는 I/O 작업은 이 쓰레드에서 처리되어야 함
└ 파일을 읽거나 AAC의 Room 등도 여기에 해당됨

Dispatchers.Main
└ 안드로이드의 메인(UI) 쓰레드입니다. UI 작업은 여기서 처리되어야 함

// 코루틴 인스턴스 초기화 예시

val scope = CoroutineScope(Dispatcher.Default)

// 코루틴 실행하기
└ 생성한 Scope 인스턴스에 두가지 함수를 사용하여 새로운 코루틴을 생성할 수 있음.

~.launch{ ~ }
└ launch 함수는 Job 객체이며 반환값이 없다
└ ex) scope.launch{
			for(i in 1..10) {
				println(i)
			}
		 }
	└ 반환값 없음

~.async{ ~ }
└ async 함수는 Deffered 객체이며 반환값이 있다
	└ 마지막 구문의 실행 결과를 반환한다.
└ ex) scope.async{
			var sum = 0
			for(i in 1..0) {
				sum++
			}
			sum
		 }
	└ 마지막 값(sum)이 반환된다

스코프 내부에서는 또 다른 launch{ ~ }나 async{ ~ }를 만들 수 있다. 이 때는 참조연산자를 사용하지 않는다(않아도 된다?).

// 실행되지 않는 코루틴 코딩 예시

import kotlinx.coroutines.*

fun main() {
    val scope = GlobalScope
    scope.launch {
        for(i in 1..5) {
            println(i)
        }
    }
}
└ scope.launch { }
	└ 스코프에 '.launch {}'를 씀으로서 Job 객체의 코루틴 하나를 만들음.
└ 실행되지 않는 이유
	└ 코루틴은 제어되는 스코프 또는 프로그램 전체가 종료되면 함께 종료됨
	└ 코루틴이 끝까지 실행되는 것을 보장하려면 일정한 범위에서 코루틴이 모두 실행될 때까지 잠시 기다려주어야 하는데 예시는 main()함수 하나 뿐이므로 프로세스가 거의 실행 즉시 종료되는 것과 같아 코루틴이 동작하지 못했음.
	└ 아래 함수들을 위와 같은 경우를 예방하기 위해 사용함

// 루틴의 동기(대기 후) 실행을 위한 "blocking 함수"

1. runBlocking{ }
└ 블럭 스코프 내부의 코루틴들이 종료될 때까지 메인 루틴을 잠시 대기시켜준다
└ 메인 스레드에서 runBlocking을 걸어주고서 일정 시간 이상 응답이 없는 경우 ANR이 발생해 앱이 강제 종료되므로 주의.
└ ex) runBlocking{
			launch {}
			async {}
		 }

2. delay(milisecond: Long)
└ milisecond 단위로 루틴을 잠시 대기시키는 함수

3. Job.join()
└ Job(launch)의 실행이 끝날 때까지(루틴이 모두 실행될 때까지) 대기하는 함수

4. Deffered.await()
└ Deferred(async)의 실행이 끝날 때까지(루틴이 모두 실행될 때까지) 대기하는 함수
└ async{}의 특징처럼 역시 결과값을 반환한다.

5. withContext(디스패처) { }
└ async{ }와 동일한 역할을 하면서 .await()의 기능까지 추가된 함수.
└ Deferred(async)의 실행이 끝날 때까지(루틴이 모두 실행될 때까지) 대기한다.
└ ex) val name = withContext(Dispatchers.Main) {
			sleep(2000)
			"My name is Android"
		 }

delay, join, await 세 함수는 코루틴 내부 영역이나 runBlocking과 같이 루틴의 대기가 가능한 구문 안에서만 사용할 수 있음.

// ~.cancel()
└ 코루틴의 실행을 중간에 중단함
다음 두가지 조건이 발생하며 코루틴을 중단시킬 수 있음.
	└ 1. 코루틴 내부의 delay()함수 또는 yield()함수가 사용된 위치까지 수행된 뒤 종료함
	└ 2. cancel()로 인해, 코루틴 내부에서 속성값인 isActive가 false가 되므로 이를 확인하여 수동으로 종료함

// 예시

fun main() {
    runBlocking {
        val a = launch {
            for(i in 1..5) {
                println(i)
                delay(10)
            }
        }
        
        val b = async {
            "async 종료"
        }

        println("async 대기") 
        println(b.await())
        
//         // launch 예시 1
//         println("launch 대기")
//         a.join()
//         println("launch 종료")
        
        // launch 예시 2
        println("launch 취소")
        a.cancel()
        println("launch 종료")
    }
}
└ 위 코드를 실행하면 먼저 .await() 함수로 async가 끝날 때까지 대기하다가 결과를 받아 출력하고, 다시 launch가 끝날 때까지 대기하다가 launch가 끝난 다음 launch가 종료되었음을 출력한다
└ runBlocking { }
	└ "runBlocking 블럭을 만든다"고 표현한다.
	└ 메인 루틴에 블록을 만듦
└ val a = launch { }
	└ Job 객체 생성
└ val b = async { }
	└ Deferred 객체 생성
└ println(b.await())
	└ 메인 루틴에서 문자열을 출력함
	└ b에 await, 즉 비동기를 걸어주고 결과(async{}내의 반환값)를 출력
└ a.join()
	└ a에 join, 즉 비동기를 걸어 a가 끝날 때까지 대기한다
└ a.cancel()
	└ a에 cancel을 걸어 실행 도중에 중단시킨다.

// Suspend functions
└ 일반적인 메소드는 코루틴 내부에서 호출할 수 없음?
└ 코루틴에서 실행할 수 있는 메소드를 만들려면 함수를 정의할 때 suspend를 붙여준다.
└ suspend가 붙은 메소드는 코루틴 내부에서만 사용할 수 있음
	└ 비동기로 처리되어야 하는 함수에 붙여준다.
└ suspend 함수는 안에서 다른 코루틴을 실행할 수도 있음

// 예시

GlobalScope.launch {
    doSomething()
    Log.d(TAG, "done something")
}

private suspend fun doSomething() {
    GlobalScope.launch {
        sleep(1000)
        Log.d(TAG, "do something in a suspend method")
    }
}
└ suspend doSomething() 함수 내부에서 launch를 또 실행함.

// 코루틴 미뤄서 실행하기 예시
val job = GlobalScope.launch(start = CoroutineStart.LAZY) {	// LAZY로 start 설정
        println("launch Start")
    }





/////////////////////// 강의 외 지식 수집 ///////////////////////





//// 싱글턴 패턴(Singleton pattern)

└ 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다.
└ 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다.
└ 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.





//// Thread synchronized (동기화)

synchronized 키워드를 사용하면, Multi-Thread 상태에서 동일한 자원을 동시에 접근하게 되었을 때 동시 접근을 막게 된다.

synchronized
└ 단 하나의 쓰레드만 실행할 수 있는 메소드 또는 블록을 말한다.
└ 다른 쓰레드는 메소드나 블록이 실행이 끝날 때까지 대기해야 한다.

// 동기화 메소드/블록에서만 호출 가능한 메소드

wait(), notify(), notifyAll()
└ 두개의 쓰레드가 교대로 번갈아 가며 실행해야 할 경우에 주로 사용한다.
└ wait()
	└ 호출한 쓰레드는 일시 정지가 된다.
└ notify() / notifyAll()
	└ 다른 쓰레드가 실행 대기 상태가 된다.

// 사용시 주의사항

임계 영역은 멀티쓰레드 프로그램의 성능을 좌우하기 때문에 가능하면 메소드 전체에 Lock을 거는 것보다 ★★★synchronized 블럭으로 임계 영역을 최소화해서★★★ 보다 효율적인 프로그램이 되도록 노력해야 한다.

synchronized를 대충 사용하면 퍼포먼스 저하, 예상치 못한 동작이 발생할 수 있다

쓰레드는 자신의 run() 메소드가 모두 실행되면 자동적으로 종료된다.

// 동기화 사용하기

1. 메서드에 synchronized 하기

	- synchronized 를 붙이면 메소드 전체가 임계 영역으로 설정된다.

	- 쓰레드는 synchronized 메소드가 호출된 시점부터 해당 메소드가 포함된 객체의 Lock을 얻어 작업을 수행하다가 메소드가 종료되면 Lock 을 반환한다.

	- synchronized 메서드를 생성시, 이 함수가 포함된 클래스(객체)에 lock을 건다.
	└ 하나의 클래스에 두개의 synchronized 메서드를 작성후 두개를 동시에 실행하려고 하면 둘 다 실행되지 않는다.
		└ 이 두 메서드 중 하나를 먼저 실행한 다음 나머지 메서드를 실행하려고 하면 나머지 메서드는 실행되지 않는다. 이전에 실행된 메서드가 종료될 때까지 대기해야 한다.
	
2. 블록에 synchronized 하기

	- 메소드 내의 코드 일부를 블럭{} 으로 감싸고 블럭 앞에 synchronized(참조변수)를 붙이는 것이다.

	- 이때 '참조변수'는 Lock 을 걸고자 하는 "객체"를 참조하는 것이어야 한다.
		ex) synchronized(ContactDatabase::class) { }

	- 이 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 Lock 을 얻게 되고, 이 블럭을 벗어나면 Lock 을 반납한다.

	- synchronized(this) { } 는 메서드 하나를 synchronized로 선언한 것과 같으므로 주의.





//// 라이브러리에 포함된 'ktx'

라이브러리에 '-ktx'가 포함되어 있으면 코틀린의 확장 함수를 사용할 수 있게 여러가지 기능이 더 추가되어 있는 것임





//// AAC

Android Architecture Components

Android 아키텍처 구성요소는 강력하고 테스트와 유지관리가 쉬운 앱을 디자인하도록 돕는 라이브러리 모음

Livedata를 사용하여 기본 데이터베이스가 변경되면 뷰에 알리는 데이터 객체를 빌드

	* MutableLiveData란 변경할 수 있는 LiveData 형입니다.
	일반적인 LiveData형은 변경할 수 없고 오로지 데이터의 변경값만을 소비하는데 반해
	MutableLiveData는 데이터를 UI Thread와 Background Thread에서 선택적으로 바꿀 수 있습니다.
	
	* MutableLiveData에 setValue 혹은 PostValue에서 실행하게되는데 두개의 차이점은 setValue에서는 UI Thread즉 Main Thread에서 실행하고 두번째는 Background Thread에서 처리합니다.

ViewModel은 앱 회전 시 제거되지 않는 UI 관련 데이터를 저장

Room은 SQLite 객체 매핑 라이브러리입니다. 이것을 사용하여 상용구 코드를 피하고 SQLite 테이블 데이터를 자바 객체로 쉽게 변환
	Room은 SQLite 문의 컴파일 시간 확인을 제공하며 RxJava, Flowable, LiveData observable을 반환할 수 있음





//// by - 위임

	- 종속성, 의존성 문제를 해결할 때 Delegation pattern(위임 패턴)은 상속의 좋은 대안으로 증명됨
	└ Delegation pattern (위임 패턴)
		└ 소프트웨어 엔지니어링에서 위임 패턴은 객체 구성에서 상속과 동일한 코드 재사용을 가능하게 해주는 객체지향 디자인 패턴입니다.
	
	- Kotlin에서는 언어 자체에서 이러한 위임 패턴을 by라는 키워드를 통해 지원함

	- 상속을 허용하지 않는 클래스에 새로운 기능을 추가할때는 위임을 사용할 수 있음

	- 위임을 사용하면 상속하지 않고 기존 기능을 그대로 사용하면서 새로운 기능을 추가할 수 있음

	- 코틀린에서는 by 키워드를 사용하여 위임 기능을 사용할 수 있음

